1. Write pseudocode for bubble sort.


FUNCTION bubbleSort(collection)
   REPEAT
     SET swapped to false

     FOR i = FIRST INDEX of collection to LAST INDEX of collection - 1
       IF collection[i] > collection[i + 1] THEN
         	SWAP(collection[i], collection[i + 1] )         
SET swapped to true
       END IF
     END FOR
   UNTIL swapped is FALSE

   RETURN collection
 END FUNCTION


2. Write pseudocode for quicksort.

FUNCTION quickSort(collection)
   SET pivot to LAST INDEX of collection
   SET greater to empty array
   SET lesser to empty array

   FOR i = FIRST INDEX of collection to LAST INDEX of collection -1
     IF collection[i] > pivot THEN
       APPEND collection[i] to greater
     ELSE
       APPEND collection[i] to lesser
     END IF
   END FOR
   CALL quickSort WITH lesser RETURNING sortedLesser
   CALL quickSort WITH greater RETURNING sortedGreater
   CALL concatate WITH sortedlesser and sortedGreater
END FUNCTION

3. We talked about time complexity in a previous checkpoint, and how to get an idea of the efficiency of an algorithm. 
After looking at the pseudocode for the above sorting methods, identify why merge sort and quick sort are much more 
efficient than the others. Walking through each algorithm with a few sample collections may help.


Merge Sorts and Quicksort takes advantage of recursion -- the ability to for the
functions to call themselves. The other sorting algorithms have to go through loops
"twice" together their process to work (thus O(n^2)) while the Merge Sort and Quicksort end
up having a slight edge (O(n log n)):

 Quicksort O(n log n)
 Merge Sort O(n log n)
 Insert Sort O(n^2)
 Selection Sort O(n^2)
 Bubble Sort O(n^2)


4. All of the sorts addressed in this checkpoint are known as comparison sorts. Research bucket sort and explain how
it works. What is the ideal input for bucket sort?

Bucket sort works by separating all elements into sub-arrays. Each put into a sub-array that meets its conditions. Which 
in turn in sorted further until no more sorting can be done and is joined back into one array. The ideal input for bucket 
sort is numerical due to being able to easily put all numbers from one to ten into a bucket then the same with twenties and thirties.  
