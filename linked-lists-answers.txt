Exercises

1. What are some pros and cons of using linked lists instead of arrays?

Pros:
* Our list never contains empty placeholders, since each one only points towards another instance. 
* The Operating System may use any available memory location to store it because each node is independent in memory.  This is probably the most important advantage over Arrays. 
Cons:
Since there is not an index to use to fine the node, it can be very inefficient to access an element in the list, because they have to be address in order. This starts from the first node, called the head. Arrays, on the other hand, can be access immediately by stating the index of the element within the array. 

2. Come up with a real world example of a linked list.

An example might be trying to find a store in a mall without a map. They don't have addresses, so there is no index. But at each store, you can see the name of the store in front of you, and the fact that there is only one direction to go to see the next store -- in a linear fashion. You go from store to store along that path until you find the store you want. 


PROGRAMMING QUESTIONS

1. The linked list push function should take a value, create a node, and add it to the end of a list. Below is pseudocode 
for a push function for a singly linked list. However, there is something wrong with it. Submit both an explanation of the 
bug and a functional implementation of the method.

---
FUNCTION push(element)
CREATE node
SET node.value TO element
SET node.next TO null

IF the head node does not exist
 THEN SET head to node
ELSE
 SET current to head
 SET current.next to node
END IF
END FUNCTION
---

The bug with this code can be found within this part:
---
ELSE
 SET current to head
 SET current.next to node

The code that is being written will put the created node behind the head(if the list is not empty),
no matter how many nodes are already on the list.
So this code will only work correctly if there are going to be
one or two nodes on the list. Three or more, and the code will not work as you want it to. 

Here is a functional implementation of the method:

function push(element){
	var newnode = new Node(element)
	newnode.next= null;
	if(headNode == null){
		var headNode = newnode;
	}else{
		var current = headNode;
		
		while(current.next !== null){
			current = current.next;
		}
		current.next = newNode;
	}
}



2. Given an unsorted singly linked list, remove all duplicates from the linked list.

class Node {
	constructor(value){
		this.value = value;
		this.next = null;
	}
}

class LinkedList {
	constructor() {
    this.head = null;
    this.length = 0;
  }
  
	create(value) {
		var newNode = new Node(value);
    
		if (this.head === null) {
		this.head = newNode;
		} else {
		var currentNode = this.head;
		
		while (currentNode.next !== null) {
			currentNode = currentNode.next;
		}
      
		currentNode.next = newNode;
		}
		this.length++;
	}
  
  
	print() {
		var currentNode = this.head;
		
		while (currentNode !== null) {
		console.log(currentNode.value);
		currentNode = currentNode.next;
		}
	}
	remove(){
		var searcher = this.head;
		var current = searcher.next;
		var prev;
		while (searcher !== null){
			while(current !== null){
				if(searcher.value == current.value && searcher.next.value == current.value){
					searcher.next = current.next;
					current = searcher.next;
					this.length -=1;
				}
				else if(searcher.value == current.value){
					prev.next = current.next;
					current = prev.next;
					this.length -=1;
				}
				else{
					prev = current;
					current = current.next;
				}
			}
			searcher = searcher.next;
			if(searcher === null){
			}else{current = searcher.next}
		}
	}
}

var testList = new LinkedList();

testList.create('a');
testList.create('c');
testList.create('a');
testList.create('c');
testList.create('b');

console.log("Linked list before removing duplicates ");
testList.print();
testList.remove();
console.log("Linked list after removing duplicates ");
testList.print();

3. Given an unsorted singly linked list, reverse it.
class Node {
	constructor(value){
		this.value = value;
		this.next = null;
	}
}

class LinkedList {
	constructor() {
    this.head = null;
    this.length = 0;
  }
  
	create(value) {
		var newNode = new Node(value);
    
		if (this.head === null) {
		this.head = newNode;
		} else {
		var currentNode = this.head;
		
		while (currentNode.next !== null) {
			currentNode = currentNode.next;
		}
      
		currentNode.next = newNode;
		}
		this.length++;
	}
  
  
	print() {
		var currentNode = this.head;
		
		while (currentNode !== null) {
		console.log(currentNode.value);
		currentNode = currentNode.next;
		}
	}
	reverse(){
		var current = this.head;
		var prev = null;
		var next;
		while (current){
			next = current.next; 
			current.next = prev; 
			prev = current; 
			current = next;
		}
      this.head = prev;
	}
}

var testList = new LinkedList();

testList.create('a');
testList.create('b');
testList.create('c');
testList.create('d');

console.log("Before list is reversed");
testList.print();
testList.reverse();
console.log("After list is reversed");
testList.print();